{
  "source": "unified-ast-grep-with-coderabbit-patterns",
  "version": "4.0.0",
  "timestamp": "2025-09-27T17:52:59.761588",
  "patterns": {
    "python_async": [
      {
        "id": "async-function",
        "pattern": "async def $FUNC($$$): $$$",
        "description": "Async function definition",
        "quality": "good",
        "weight": 2,
        "language": "python"
      },
      {
        "id": "async-with",
        "pattern": "async with $RESOURCE: $$$",
        "description": "Async context manager",
        "quality": "good",
        "weight": 3,
        "language": "python"
      },
      {
        "id": "await-gather",
        "pattern": "await asyncio.gather($$$)",
        "description": "Parallel async execution",
        "quality": "good",
        "weight": 4,
        "language": "python"
      },
      {
        "id": "await-call",
        "pattern": "await $FUNC($$$)",
        "description": "Awaited async call",
        "quality": "neutral",
        "weight": 1,
        "language": "python"
      }
    ],
    "python_error_handling": [
      {
        "id": "specific-except",
        "pattern": "except $ERROR: $$$",
        "description": "Specific exception handling",
        "quality": "good",
        "weight": 3,
        "language": "python"
      },
      {
        "id": "broad-except",
        "pattern": "except: $$$",
        "description": "Bare except clause",
        "quality": "bad",
        "weight": -3,
        "language": "python"
      },
      {
        "id": "try-finally",
        "pattern": "try: $TRY finally: $FINALLY",
        "description": "Try-finally block",
        "quality": "good",
        "weight": 2,
        "language": "python"
      }
    ],
    "python_logging": [
      {
        "id": "logger-call",
        "pattern": "logger.$METHOD($$$)",
        "description": "Logger usage",
        "quality": "good",
        "weight": 2,
        "language": "python"
      },
      {
        "id": "print-call",
        "pattern": "print($$$)",
        "description": "Print statement",
        "quality": "bad",
        "weight": -1,
        "language": "python"
      },
      {
        "id": "debug-print-f-sq",
        "pattern": "print(f'$A')",
        "description": "F-string print (single quote)",
        "quality": "bad",
        "weight": -2,
        "language": "python"
      },
      {
        "id": "debug-print-f-dq",
        "pattern": "print(f\"$A\")",
        "description": "F-string print (double quote)",
        "quality": "bad",
        "weight": -2,
        "language": "python"
      },
      {
        "id": "debug-print",
        "pattern": "print(f$$$)",
        "description": "F-string print",
        "quality": "bad",
        "weight": -2,
        "language": "python",
        "category": "python_logging"
      }
    ],
    "python_typing": [
      {
        "id": "typed-function",
        "pattern": "def $FUNC($$$) -> $RETURN: $$$",
        "description": "Function with return type",
        "quality": "good",
        "weight": 3,
        "language": "python"
      },
      {
        "id": "typed-async",
        "pattern": "async def $FUNC($$$) -> $RETURN: $$$",
        "description": "Async function with return type",
        "quality": "good",
        "weight": 4,
        "language": "python"
      },
      {
        "id": "type-annotation",
        "pattern": "$VAR: $TYPE = $$$",
        "description": "Variable type annotation",
        "quality": "good",
        "weight": 2,
        "language": "python"
      }
    ],
    "python_antipatterns": [
      {
        "id": "sync-sleep",
        "pattern": "time.sleep($$$)",
        "description": "Blocking sleep in async context",
        "quality": "bad",
        "weight": -5,
        "language": "python"
      },
      {
        "id": "sync-open",
        "pattern": "open($$$)",
        "description": "Sync file open (should use aiofiles)",
        "quality": "bad",
        "weight": -3,
        "language": "python"
      },
      {
        "id": "requests-call",
        "pattern": "requests.$METHOD($$$)",
        "description": "Sync HTTP request (should use aiohttp)",
        "quality": "bad",
        "weight": -4,
        "language": "python"
      },
      {
        "id": "global-var",
        "pattern": "global $VAR",
        "description": "Global variable usage",
        "quality": "bad",
        "weight": -2,
        "language": "python"
      },
      {
        "id": "mutable-default",
        "pattern": "def $FUNC($$$, $ARG=[]): $$$",
        "description": "Mutable default argument",
        "quality": "bad",
        "weight": -4,
        "language": "python"
      }
    ],
    "python_qdrant": [
      {
        "id": "qdrant-search",
        "pattern": "$CLIENT.search($$$)",
        "description": "Qdrant search operation",
        "quality": "neutral",
        "weight": 1,
        "language": "python"
      },
      {
        "id": "qdrant-upsert",
        "pattern": "$CLIENT.upsert($$$)",
        "description": "Qdrant upsert operation",
        "quality": "neutral",
        "weight": 1,
        "language": "python"
      },
      {
        "id": "collection-create",
        "pattern": "create_collection($$$)",
        "description": "Collection creation",
        "quality": "neutral",
        "weight": 1,
        "language": "python"
      }
    ],
    "python_mcp": [
      {
        "id": "mcp-tool",
        "pattern": "@server.tool\nasync def $TOOL($$$): $$$",
        "description": "MCP tool definition",
        "quality": "good",
        "weight": 5,
        "language": "python"
      },
      {
        "id": "mcp-resource",
        "pattern": "@server.resource($$$)\nasync def $RESOURCE($$$): $$$",
        "description": "MCP resource definition",
        "quality": "good",
        "weight": 5,
        "language": "python"
      }
    ],
    "go_catalog": [
      {
        "id": "match-package-import",
        "title": "Match package import in Golang",
        "description": "A generic rule template for detecting imports of specific packages in Go source code. This rule can be customized to match any package by modifying the regex pattern, making it useful for security auditing, dependency management, and compliance checking.\n\nThis rule identifies Go import statements based on the configured regex pattern, including:\n\nDirect imports: `import \"package/name\"`  \nVersioned imports: `import \"package/name/v4\"`  \nSubpackage imports: `import \"package/name/subpkg\"`  \nGrouped imports within `import () blocks`",
        "language": "go",
        "file": "match-package-import.md",
        "has_fix": false,
        "quality": "neutral",
        "weight": 1
      },
      {
        "id": "unmarshal-tag-is-dash",
        "title": "Detect problematic JSON tags with dash prefix",
        "description": "This rule detects a security vulnerability in Go's JSON unmarshaling. When a struct field has a JSON tag that starts with `-,`, it can be unexpectedly unmarshaled with the `-` key.\n\nAccording to the [Go documentation](https://pkg.go.dev/encoding/json#Marshal), if the field tag is `-`, the field should be omitted. However, a field with name `-` can still be unmarshaled using the tag `-,`.\n\nThis creates a security issue where developers think they are preventing a field from being unmarshaled (like `IsAdmin` in authentication), but attackers can still set that field by providing the `-` key in JSON input.",
        "language": "go",
        "file": "unmarshal-tag-is-dash.md",
        "has_fix": false,
        "pattern": "`$TAG`",
        "inside": {
          "kind": "field_declaration"
        },
        "quality": "neutral",
        "weight": 1
      },
      {
        "id": "match-function-call",
        "title": "Match Function Call in Golang",
        "description": "One of the common questions of ast-grep is to match function calls in Golang.\n\nA plain pattern like `fmt.Println($A)` will not work. This is because Golang syntax also allows type conversions, e.g. `int(3.14)`, that look like function calls. Tree-sitter, ast-grep's parser, will prefer parsing `func_call(arg)` as a type conversion instead of a call expression.\n\nTo avoid this ambiguity, ast-grep lets us write a [contextual pattern](/guide/rule-config/atomic-rule.html#pattern), which is a pattern inside a larger code snippet.\nWe can use `context` to write a pattern like this: `func t() { fmt.Println($A) }`. Then, we can use the selector `call_expression` to match only function calls.\n\nPlease also read the [deep dive](/advanced/pattern-parse.html) on [ambiguous pattern](/advanced/pattern-parse.html#ambiguous-pattern-code).",
        "language": "go",
        "file": "match-function-call.md",
        "has_fix": false,
        "pattern": {
          "context": "func t() { fmt.Println($A) }",
          "selector": "call_expression"
        },
        "quality": "neutral",
        "weight": 1
      },
      {
        "id": "test-functions",
        "title": "Find function declarations with names of certain pattern",
        "description": "ast-grep can find function declarations by their names. But not all names can be matched by a meta variable pattern. For instance, you cannot use a meta variable pattern to find function declarations whose names start with a specific prefix, e.g. `TestAbs` with the prefix `Test`. Attempting `Test$_` will fail because it is not a valid syntax.\n\nInstead, you can use a [YAML rule](/reference/rule.html) to use the [`regex`](/guide/rule-config/atomic-rule.html#regex) atomic rule.",
        "language": "go",
        "file": "find-func-declaration-with-prefix.md",
        "has_fix": false,
        "quality": "neutral",
        "weight": 1
      }
    ],
    "python_catalog": [
      {
        "id": "refactor-pytest-fixtures",
        "title": "Refactor pytest fixtures",
        "description": "One of the most commonly used testing framework in Python is [pytest](https://docs.pytest.org/en/8.2.x/). Among other things, it allows the use of [fixtures](https://docs.pytest.org/en/6.2.x/fixture.html).\n\nFixtures are defined as functions that can be required in test code, or in other fixtures, as an argument. This means that all functions arguments with a given name in a pytest context (test function or fixture) are essentially the same entity. However, not every editor's LSP is able to keep track of this, making refactoring challenging.\n\nUsing ast-grep, we can define some rules to match fixture definition and usage without catching similarly named entities in a non-test context.\n\nFirst, we define utils to select pytest test/fixture functions.",
        "language": "python",
        "file": "refactor-pytest-fixtures.md",
        "has_fix": false,
        "quality": "neutral",
        "weight": 1
      },
      {
        "id": "optional-to-none-union",
        "title": "Rewrite `Optional[Type]` to `Type | None`",
        "description": "[PEP 604](https://peps.python.org/pep-0604/) recommends that `Type | None` is preferred over `Optional[Type]` for Python 3.10+.\n\nThis rule performs such rewriting. Note `Optional[$T]` alone is interpreted as subscripting expression instead of generic type, we need to use [pattern object](/guide/rule-config/atomic-rule.html#pattern-object) to disambiguate it with more context code.\n\n<!-- Use YAML in the example. Delete this section if use pattern. -->",
        "language": "python",
        "file": "optional-to-none-union.md",
        "has_fix": true,
        "pattern": {
          "context": "a: Optional[$T]",
          "selector": "generic_type"
        },
        "fix": "$T | None",
        "quality": "good",
        "weight": 3
      },
      {
        "id": "prefer-generator-expressions",
        "title": "Prefer Generator Expressions",
        "description": "List comprehensions like `[x for x in range(10)]` are a concise way to create lists in Python. However, we can achieve better memory efficiency by using generator expressions like `(x for x in range(10))` instead. List comprehensions create the entire list in memory, while generator expressions generate each element one at a time. We can make the change by replacing the square brackets with parentheses.",
        "language": "python",
        "file": "prefer-generator-expressions.md",
        "has_fix": true,
        "pattern": "$LIST",
        "fix": "($INNER)",
        "quality": "good",
        "weight": 3
      },
      {
        "id": "remove-async-def",
        "title": "Remove `async` function",
        "description": "The `async` keyword in Python is used to define asynchronous functions that can be `await`ed.\n\nIn this example, we want to remove the `async` keyword from a function definition and replace it with a synchronous version of the function. We also need to remove the `await` keyword from the function body.\n\nBy default, ast-grep will not apply overlapping replacements. This means `await` keywords will not be modified because they are inside the async function body.\n\nHowever, we can use the [`rewriter`](https://ast-grep.github.io/reference/yaml/rewriter.html) to apply changes inside the matched function body.",
        "language": "python",
        "file": "remove-async-await.md",
        "has_fix": true,
        "pattern": {
          "context": "async def $FUNC($$$ARGS): $$$BODY",
          "selector": "function_definition"
        },
        "fix": "def $FUNC($$$ARGS):\n  $REMOVED_BODY",
        "quality": "good",
        "weight": 3
      },
      {
        "id": "use-walrus-operator",
        "title": "Use Walrus Operator in `if` statement",
        "description": "The walrus operator (`:=`) introduced in Python 3.8 allows you to assign values to variables as part of an expression. This rule aims to simplify code by using the walrus operator in `if` statements.\n\nThis first part of the rule identifies cases where a variable is assigned a value and then immediately used in an `if` statement to control flow.",
        "language": "python",
        "file": "use-walrus-operator-in-if.md",
        "has_fix": true,
        "pattern": "if $VAR: $$$B",
        "fix": "if $VAR := $$$EXPR:\n  $$$B",
        "quality": "good",
        "weight": 3
      }
    ],
    "tsx_catalog": [
      {
        "id": "unnecessary-react-hook",
        "title": "Avoid Unnecessary React Hook",
        "description": "React hook is a powerful feature in React that allows you to use state and other React features in a functional component.\n\nHowever, you should avoid using hooks when you don't need them. If the code does not contain using any other React hooks,\nit can be rewritten to a plain function. This can help to separate your application logic from the React-specific UI logic.",
        "language": "Tsx",
        "file": "unnecessary-react-hook.md",
        "has_fix": false,
        "patterns": [
          {
            "pattern": "function $FUNC($$$) { $$$ }"
          },
          {
            "pattern": "let $FUNC = ($$$) => $$$"
          },
          {
            "pattern": "const $FUNC = ($$$) => $$$"
          }
        ],
        "match_type": "any",
        "quality": "neutral",
        "weight": 1
      },
      {
        "id": "do-what-brooooooklyn-said",
        "title": "Avoid `&&` short circuit in JSX",
        "description": "In [React](https://react.dev/learn/conditional-rendering), you can conditionally render JSX using JavaScript syntax like `if` statements, `&&`, and `? :` operators.\nHowever, you should almost never put numbers on the left side of `&&`. This is because React will render the number `0`, instead of the JSX element on the right side. A concrete example will be conditionally rendering a list when the list is not empty.\n\nThis rule will find and fix any short-circuit rendering in JSX and rewrite it to a ternary operator.",
        "language": "Tsx",
        "file": "avoid-jsx-short-circuit.md",
        "has_fix": true,
        "fix": "{$A ? $B : null}",
        "quality": "good",
        "weight": 3
      },
      {
        "id": "rewrite-mobx-component",
        "title": "Rewrite MobX Component Style",
        "description": "React and MobX are libraries that help us build user interfaces with JavaScript.\n\n[React hooks](https://react.dev/reference/react) allow us to use state and lifecycle methods in functional components. But we need follow some hook rules, or React may break. [MobX](https://mobx.js.org/react-integration.html) has an `observer` function that makes a component update when data changes.\n\nWhen we use the `observer` function like this:",
        "language": "typescript",
        "file": "rewrite-mobx-component.md",
        "has_fix": true,
        "pattern": "export const $COMP = observer($FUNC)",
        "fix": "const Base$COMP = $FUNC\nexport const $COMP = observer(Base$COMP)",
        "quality": "good",
        "weight": 3
      },
      {
        "id": "rewrite-svg-attribute",
        "title": "Rename SVG Attribute",
        "description": "[SVG](https://en.wikipedia.org/wiki/SVG)(Scalable Vector Graphics)s' hyphenated names are not compatible with JSX syntax in React. JSX requires [camelCase naming](https://react.dev/learn/writing-markup-with-jsx#3-camelcase-salls-most-of-the-things) for attributes.\nFor example, an SVG attribute like `stroke-linecap` needs to be renamed to `strokeLinecap` to work correctly in React.",
        "language": "tsx",
        "file": "rename-svg-attribute.md",
        "has_fix": true,
        "pattern": "$PROP",
        "inside": {
          "kind": "jsx_attribute"
        },
        "fix": "$NEW_PROP",
        "quality": "good",
        "weight": 3
      },
      {
        "id": "no-nested-links",
        "title": "Avoid nested links",
        "description": "React will produce a warning message if you nest a link element inside of another link element. This rule will catch this mistake!",
        "language": "tsx",
        "file": "avoid-nested-links.md",
        "has_fix": false,
        "pattern": "<a $$$>$$$A</a>",
        "quality": "bad",
        "weight": -3
      }
    ],
    "typescript_catalog": [
      {
        "id": "no-await-in-promise-all",
        "title": "No `await` in `Promise.all` array",
        "description": "Using `await` inside an inline `Promise.all` array is usually a mistake, as it defeats the purpose of running the promises in parallel. Instead, the promises should be created without `await` and passed to `Promise.all`, which can then be awaited.\n\n<!-- Use YAML in the example. Delete this section if use pattern. -->",
        "language": "typescript",
        "file": "no-await-in-promise-all.md",
        "has_fix": true,
        "pattern": "await $A",
        "inside": {
          "pattern": "Promise.all($_)",
          "stopBy": {
            "not": {
              "any": [
                {
                  "kind": "array"
                },
                {
                  "kind": "arguments"
                }
              ]
            }
          }
        },
        "fix": "$A",
        "quality": "good",
        "weight": 3
      },
      {
        "id": "find-import-usage",
        "title": "Find Import Usage",
        "description": "It is common to find the usage of an imported module in a codebase. This rule helps you to find the usage of an imported module in your codebase.\nThe idea of this rule can be broken into several parts:\n\n* Find the use of an identifier `$MOD`\n* To find the import, we first need to find the root file of which `$MOD` is  `inside`\n* The `program` file `has` an `import` statement\n* The `import` statement `has` the identifier `$MOD`\n\n<!-- Use YAML in the example. Delete this section if use pattern. -->",
        "language": "typescript",
        "file": "find-import-usage.md",
        "has_fix": false,
        "pattern": "$MOD",
        "inside": {
          "stopBy": "end",
          "kind": "program",
          "has": {
            "kind": "import_statement",
            "has": {
              "stopBy": "end",
              "kind": "import_specifier",
              "pattern": "$MOD"
            }
          }
        },
        "quality": "neutral",
        "weight": 1
      },
      {
        "id": "find-all-imports-and-identifiers",
        "title": "Find Import Identifiers",
        "description": "Finding import metadata can be useful. Below is a comprehensive snippet for extracting identifiers from various import statements:\n\n* Alias Imports (`import { hello as world } from './file'`)\n* Default & Regular Imports (`import test from './my-test`')\n* Dynamic Imports (`require(...)`, and `import(...)`)\n* Side Effect & Namespace Imports (`import * as myCode from './code`')\n\n<!-- Use YAML in the example. Delete this section if use pattern. -->",
        "language": "TypeScript",
        "file": "find-import-identifiers.md",
        "has_fix": false,
        "patterns": [
          {
            "all": [
              {
                "kind": "import_specifier"
              },
              {
                "has": {
                  "field": "alias",
                  "pattern": "$ALIAS"
                }
              },
              {
                "has": {
                  "field": "name",
                  "pattern": "$ORIGINAL"
                }
              },
              {
                "inside": {
                  "stopBy": "end",
                  "kind": "import_statement",
                  "has": {
                    "field": "source",
                    "pattern": "$SOURCE"
                  }
                }
              }
            ]
          },
          {
            "all": [
              {
                "kind": "import_statement"
              },
              {
                "has": {
                  "kind": "import_clause",
                  "has": {
                    "kind": "identifier",
                    "pattern": "$DEFAULT_NAME"
                  }
                }
              },
              {
                "has": {
                  "field": "source",
                  "pattern": "$SOURCE"
                }
              }
            ]
          },
          {
            "all": [
              {
                "kind": "import_specifier"
              },
              {
                "has": {
                  "field": "name",
                  "pattern": "$ORIGINAL"
                }
              },
              {
                "inside": {
                  "stopBy": "end",
                  "kind": "import_statement",
                  "has": {
                    "field": "source",
                    "pattern": "$SOURCE"
                  }
                }
              }
            ]
          },
          {
            "all": [
              {
                "kind": "variable_declarator"
              },
              {
                "has": {
                  "field": "name",
                  "kind": "identifier",
                  "pattern": "$VAR_NAME"
                }
              },
              {
                "has": {
                  "field": "value",
                  "any": [
                    {
                      "all": [
                        {
                          "kind": "call_expression"
                        },
                        {
                          "has": {
                            "field": "function",
                            "regex": "^(require|import)$"
                          }
                        },
                        {
                          "has": {
                            "field": "arguments",
                            "has": {
                              "kind": "string",
                              "pattern": "$SOURCE"
                            }
                          }
                        }
                      ]
                    },
                    {
                      "kind": "await_expression",
                      "has": {
                        "all": [
                          {
                            "kind": "call_expression"
                          },
                          {
                            "has": {
                              "field": "function",
                              "regex": "^(require|import)$"
                            }
                          },
                          {
                            "has": {
                              "field": "arguments",
                              "has": {
                                "kind": "string",
                                "pattern": "$SOURCE"
                              }
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          {
            "all": [
              {
                "kind": "shorthand_property_identifier_pattern"
              },
              {
                "pattern": "$ORIGINAL"
              },
              {
                "inside": {
                  "kind": "object_pattern",
                  "inside": {
                    "kind": "variable_declarator",
                    "has": {
                      "field": "value",
                      "any": [
                        {
                          "all": [
                            {
                              "kind": "call_expression"
                            },
                            {
                              "has": {
                                "field": "function",
                                "regex": "^(require|import)$"
                              }
                            },
                            {
                              "has": {
                                "field": "arguments",
                                "has": {
                                  "kind": "string",
                                  "pattern": "$SOURCE"
                                }
                              }
                            }
                          ]
                        },
                        {
                          "kind": "await_expression",
                          "has": {
                            "all": [
                              {
                                "kind": "call_expression"
                              },
                              {
                                "has": {
                                  "field": "function",
                                  "regex": "^(require|import)$"
                                }
                              },
                              {
                                "has": {
                                  "field": "arguments",
                                  "has": {
                                    "kind": "string",
                                    "pattern": "$SOURCE"
                                  }
                                }
                              }
                            ]
                          }
                        }
                      ]
                    },
                    "stopBy": "end"
                  }
                }
              }
            ]
          },
          {
            "all": [
              {
                "kind": "pair_pattern"
              },
              {
                "has": {
                  "field": "key",
                  "kind": "property_identifier",
                  "pattern": "$ORIGINAL"
                }
              },
              {
                "has": {
                  "field": "value",
                  "kind": "identifier",
                  "pattern": "$ALIAS"
                }
              },
              {
                "inside": {
                  "kind": "object_pattern",
                  "inside": {
                    "kind": "variable_declarator",
                    "has": {
                      "field": "value",
                      "any": [
                        {
                          "all": [
                            {
                              "kind": "call_expression"
                            },
                            {
                              "has": {
                                "field": "function",
                                "regex": "^(require|import)$"
                              }
                            },
                            {
                              "has": {
                                "field": "arguments",
                                "has": {
                                  "kind": "string",
                                  "pattern": "$SOURCE"
                                }
                              }
                            }
                          ]
                        },
                        {
                          "kind": "await_expression",
                          "has": {
                            "all": [
                              {
                                "kind": "call_expression"
                              },
                              {
                                "has": {
                                  "field": "function",
                                  "regex": "^(require|import)$"
                                }
                              },
                              {
                                "has": {
                                  "field": "arguments",
                                  "has": {
                                    "kind": "string",
                                    "pattern": "$SOURCE"
                                  }
                                }
                              }
                            ]
                          }
                        }
                      ]
                    },
                    "stopBy": "end"
                  },
                  "stopBy": "end"
                }
              }
            ]
          },
          {
            "all": [
              {
                "kind": "string"
              },
              {
                "pattern": "$SOURCE"
              },
              {
                "inside": {
                  "kind": "arguments",
                  "parent": {
                    "kind": "call_expression",
                    "has": {
                      "field": "function",
                      "regex": "^(require|import)$"
                    }
                  },
                  "stopBy": "end"
                }
              },
              {
                "not": {
                  "inside": {
                    "kind": "lexical_declaration",
                    "stopBy": "end"
                  }
                }
              }
            ]
          },
          {
            "all": [
              {
                "kind": "import_statement"
              },
              {
                "has": {
                  "kind": "import_clause",
                  "has": {
                    "kind": "namespace_import",
                    "has": {
                      "kind": "identifier",
                      "pattern": "$NAMESPACE_ALIAS"
                    }
                  }
                }
              },
              {
                "has": {
                  "field": "source",
                  "pattern": "$SOURCE"
                }
              }
            ]
          },
          {
            "all": [
              {
                "kind": "import_statement"
              },
              {
                "not": {
                  "has": {
                    "kind": "import_clause"
                  }
                }
              },
              {
                "has": {
                  "field": "source",
                  "pattern": "$SOURCE"
                }
              }
            ]
          }
        ],
        "match_type": "any",
        "quality": "neutral",
        "weight": 1
      },
      {
        "id": "speed-up-barrel-import",
        "title": "Speed up Barrel Import",
        "description": "A [barrel import](https://adrianfaciu.dev/posts/barrel-files/) is a way to consolidate the exports of multiple modules into a single convenient module that can be imported using a single import statement. For instance, `import {a, b, c} from './barrel'`.\n\nIt has [some](https://vercel.com/blog/how-we-optimized-package-imports-in-next-js) [benefits](https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-7/) to import each module directly from its own file without going through the barrel file.\nSuch as reducing [bundle size](https://dev.to/tassiofront/barrel-files-and-why-you-should-stop-using-them-now-bc4), improving building time or avoiding [conflicting names](https://flaming.codes/posts/barrel-files-in-javascript/).\n\n<!-- Use YAML in the example. Delete this section if use pattern. -->",
        "language": "typescript",
        "file": "speed-up-barrel-import.md",
        "has_fix": true,
        "pattern": "import {$$$IDENTS} from './barrel'",
        "fix": "$IMPORTS",
        "quality": "good",
        "weight": 3
      },
      {
        "id": "find-import-file",
        "title": "Find Import File without Extension",
        "description": "In ECMAScript modules (ESM), the module specifier must include the file extension, such as `.js` or `.mjs`, when importing local or absolute modules. This is because ESM does not perform any automatic file extension resolution, unlike CommonJS modules tools such as Webpack or Babel. This behavior matches how import behaves in browser environments, and is specified by the [ESM module spec](https://stackoverflow.com/questions/66375075/node-14-ecmascript-modules-import-modules-without-file-extensions).\n\nThe rule finds all imports (static and dynamic) for files without a file extension.\n\n<!-- Use YAML in the example. Delete this section if use pattern. -->",
        "language": "js",
        "file": "find-import-file-without-extension.md",
        "has_fix": false,
        "patterns": [
          {
            "inside": {
              "stopBy": "end",
              "kind": "import_statement"
            }
          },
          {
            "inside": {
              "stopBy": "end",
              "kind": "call_expression",
              "has": {
                "field": "function",
                "regex": "^import$"
              }
            }
          }
        ],
        "match_type": "any",
        "quality": "neutral",
        "weight": 1
      },
      {
        "id": "missing-component-decorator",
        "title": "Missing Component Decorator",
        "description": "Angular lifecycle methods are a set of methods that allow you to hook into the lifecycle of an Angular component or directive.\nThey must be used within a class that is decorated with the `@Component()` decorator.",
        "language": "TypeScript",
        "file": "missing-component-decorator.md",
        "has_fix": false,
        "pattern": {
          "context": "class Hi { $METHOD() { $$$_} }",
          "selector": "method_definition"
        },
        "inside": {
          "pattern": "class $KLASS $$$_ { $$$_ }",
          "stopBy": "end",
          "not": {
            "has": {
              "pattern": "@Component($$$_)"
            }
          }
        },
        "quality": "bad",
        "weight": -3
      },
      {
        "id": "no-console-except-error",
        "title": "No `console` except in `catch` block",
        "description": "Using `console` methods is usually for debugging purposes and therefore not suitable to ship to the client.\n`console` can expose sensitive information, clutter the output, or affect the performance.\n\nThe only exception is using `console.error` to log errors in the catch block, which can be useful for debugging production.\n\n<!-- Use YAML in the example. Delete this section if use pattern. -->",
        "language": "typescript",
        "file": "no-console-except-catch.md",
        "has_fix": false,
        "patterns": [
          {
            "pattern": "console.error($$$)",
            "not": {
              "inside": {
                "kind": "catch_clause",
                "stopBy": "end"
              }
            }
          },
          {
            "pattern": "console.$METHOD($$$)"
          }
        ],
        "match_type": "any",
        "quality": "bad",
        "weight": -3
      }
    ],
    "rust_catalog": [
      {
        "id": "avoid-duplicate-export",
        "title": "Avoid Duplicated Exports",
        "description": "Generally, we don't encourage the use of re-exports.\n\nHowever, sometimes, to keep the interface exposed by a lib crate tidy, we use re-exports to shorten the path to specific items.\nWhen doing so, a pitfall is to export a single item under two different names.\n\nConsider:",
        "language": "rust",
        "file": "avoid-duplicated-exports.md",
        "has_fix": false,
        "patterns": [
          {
            "pattern": "pub use $B::$C;"
          },
          {
            "inside": {
              "kind": "source_file",
              "has": {
                "pattern": "pub mod $A;"
              }
            }
          },
          {
            "has": {
              "pattern": "$A",
              "stopBy": "end"
            }
          }
        ],
        "match_type": "all",
        "quality": "bad",
        "weight": -3
      }
    ],
    "java_catalog": [
      {
        "id": "no-unused-vars",
        "title": "No Unused Vars in Java",
        "description": "Identifying unused variables is a common task in code refactoring. You should rely on a Java linter or IDE for this task rather than writing a custom rule in ast-grep, but for educational purposes, this rule demonstrates how to find unused variables in Java.\n\nThis approach makes some simplifying assumptions. We only consider local variable declarations and ignore the other many ways variables can be declared: Method Parameters, Fields, Class Variables, Constructor Parameters, Loop Variables, Exception Handler Parameters, Lambda Parameters, Annotation Parameters, Enum Constants, and Record Components. Now you may see why it is recommended to use a rule from an established linter or IDE rather than writing your own.",
        "language": "java",
        "file": "no-unused-vars.md",
        "has_fix": true,
        "patterns": [
          {
            "has": {
              "has": {
                "kind": "identifier",
                "pattern": "$IDENT"
              }
            }
          },
          {
            "not": {
              "precedes": {
                "stopBy": "end",
                "has": {
                  "stopBy": "end",
                  "any": [
                    {
                      "kind": "identifier",
                      "pattern": "$IDENT"
                    },
                    {
                      "has": {
                        "kind": "identifier",
                        "pattern": "$IDENT",
                        "stopBy": "end"
                      }
                    }
                  ]
                }
              }
            }
          }
        ],
        "match_type": "all",
        "fix": "",
        "quality": "good",
        "weight": 3
      },
      {
        "id": "find-field-with-type",
        "title": "Find Java field declarations of type String",
        "description": "To extract all Java field names of type `String` is not as straightforward as one might think. A simple pattern like `String $F;` would only match fields declared without any modifiers or annotations. However, a pattern like `$MOD String $F;` cannot be correctly parsed by tree-sitter.\n\n:::details Use playground pattern debugger to explore the AST\n\nYou can use the [playground](https://ast-grep.github.io/playground.html#eyJtb2RlIjoiUGF0Y2giLCJsYW5nIjoiamF2YSIsInF1ZXJ5IjoiY2xhc3MgQUJDe1xuICAgJE1PRCBTdHJpbmcgdGVzdDtcbn0iLCJyZXdyaXRlIjoiIiwic3RyaWN0bmVzcyI6ImFzdCIsInNlbGVjdG9yIjoiIiwiY29uZmlnIjoicnVsZTpcbiAga2luZDogZmllbGRfZGVjbGFyYXRpb25cbiAgaGFzOlxuICAgIGZpZWxkOiB0eXBlXG4gICAgcmVnZXg6IF5TdHJpbmckIiwic291cmNlIjoiQENvbXBvbmVudFxuY2xhc3MgQUJDIGV4dGVuZHMgT2JqZWN0e1xuICAgIEBSZXNvdXJjZVxuICAgIHByaXZhdGUgZmluYWwgU3RyaW5nIHdpdGhfYW5ubztcblxuICAgIHByaXZhdGUgZmluYWwgU3RyaW5nIHdpdGhfbXVsdGlfbW9kO1xuXG4gICAgcHVibGljIFN0cmluZyBzaW1wbGU7XG59In0=)'s pattern tab to visualize the AST of `class A { $MOD String $F; }`.",
        "language": "java",
        "file": "find-field-with-type.md",
        "has_fix": false,
        "quality": "neutral",
        "weight": 1
      }
    ],
    "html_catalog": [
      {
        "id": "upgrade-ant-design-vue",
        "title": "Upgrade Ant Design Vue",
        "description": "ast-grep can be used to upgrade Vue template using the HTML parser.\n\nThis rule is an example to upgrade [one breaking change](https://next.antdv.com/docs/vue/migration-v4#component-api-adjustment) in [Ant Design Vue](https://next.antdv.com/components/overview) from v3 to v4, unifying the controlled visible API of the component popup.\n\nIt is designed to identify and replace the `visible` attribute with the `open` attribute for specific components like `a-modal` and `a-tooltip`. Note the rule should not replace other visible attributes that are not related to the component popup like `a-tag`.\n\nThe rule can be broken down into the following steps:\n1. Find the target attribute name by `kind` and `regex`\n2. Find the attribute's enclosing element using `inside`, and get its tag name\n3. Ensure the tag name is related to popup components, using constraints\n\n<!-- Use YAML in the example. Delete this section if use pattern. -->",
        "language": "HTML",
        "file": "upgrade-ant-design-vue.md",
        "has_fix": true,
        "fix": ":open",
        "quality": "good",
        "weight": 3
      },
      {
        "id": "extract-i18n-key",
        "title": "Extract i18n Keys",
        "description": "It is tedious to manually find and replace all the text in the template with i18n keys. This rule helps to extract static text into i18n keys. Dynamic text, e.g. mustache syntax, will be skipped.\n\nIn practice, you may want to map the extracted text to a key in a dictionary file. While this rule only demonstrates the extraction part, further mapping process can be done via a script reading the output of ast-grep's [`--json`](/guide/tools/json.html) mode, or using [`@ast-grep/napi`](/guide/api-usage/js-api.html).",
        "language": "html",
        "file": "extract-i18n-key.md",
        "has_fix": true,
        "pattern": "$T",
        "fix": "{{ $('$T') }}",
        "quality": "good",
        "weight": 3
      }
    ],
    "kotlin_catalog": [
      {
        "id": "import-dependency-violation",
        "title": "Ensure Clean Architecture",
        "description": "This ast-grep rule ensures that the **domain** package in a [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html) project does not import classes from the **data** or **presentation** packages. It enforces the separation of concerns by preventing the domain layer from depending on other layers, maintaining the integrity of the architecture.\n\nFor example, the rule will trigger an error if an import statement like `import com.example.data.SomeClass` or `import com.example.presentation.AnotherClass` is found within the domain package.\n\nThe rule uses the [`files`](/reference/yaml.html#files) field to apply only to the domain package.",
        "language": "kotlin",
        "file": "ensure-clean-architecture.md",
        "has_fix": false,
        "pattern": "import $PATH",
        "quality": "neutral",
        "weight": 1
      }
    ],
    "cpp_catalog": [
      {
        "id": "fix-format-security-error",
        "title": "Fix Format String Vulnerability",
        "description": "The [Format String exploit](https://owasp.org/www-community/attacks/Format_string_attack) occurs when the submitted data of an input string is evaluated as a command by the application.\n\nFor example, using `sprintf(s, var)` can lead to format string vulnerabilities if `var` contains user-controlled data. This can be exploited to execute arbitrary code. By explicitly specifying the format string as `\"%s\"`, you ensure that `var` is treated as a string, mitigating this risk.\n\n<!-- Use YAML in the example. Delete this section if use pattern. -->",
        "language": "Cpp",
        "file": "fix-format-vuln.md",
        "has_fix": true,
        "pattern": "$PRINTF($S, $VAR)",
        "fix": "$PRINTF($S, \"%s\", $VAR)",
        "quality": "good",
        "weight": 3
      }
    ],
    "yaml_catalog": [
      {
        "id": "detect-host-port",
        "title": "Find key/value and Show Message",
        "description": "This YAML rule helps detecting specific host and port configurations in your code. For example, it checks if the port is set to something other than 8000 or if a particular host is used. It provides an error message prompting you to update the configuration.",
        "language": "yaml",
        "file": "find-key-value.md",
        "has_fix": false,
        "patterns": [
          {
            "pattern": "port: $PORT\n"
          },
          {
            "pattern": "host: $HOST"
          }
        ],
        "match_type": "any",
        "quality": "neutral",
        "weight": 1
      }
    ],
    "c_catalog": [
      {
        "id": "may-the-force-be-with-you",
        "title": "Rewrite Check to Yoda Condition",
        "description": "In programming jargon, a [Yoda condition](https://en.wikipedia.org/wiki/Yoda_conditions) is a style that places the constant portion of the expression on the left side of the conditional statement. It is used to prevent assignment errors that may occur in languages like C.\n\n<!-- Use YAML in the example. Delete this section if use pattern. -->",
        "language": "c",
        "file": "yoda-condition.md",
        "has_fix": true,
        "pattern": "$A == $B",
        "inside": {
          "kind": "parenthesized_expression",
          "inside": {
            "kind": "if_statement"
          }
        },
        "fix": "$B == $A",
        "quality": "good",
        "weight": 3
      },
      {
        "id": "method_receiver",
        "title": "Rewrite Method to Function Call",
        "description": "",
        "language": "c",
        "file": "rewrite-method-to-function-call.md",
        "has_fix": true,
        "pattern": "$R.$METHOD($$$ARGS)",
        "fix": "$METHOD(&$R$MAYBE_COMMA$$$ARGS)",
        "quality": "good",
        "weight": 3
      },
      {
        "id": "match-function-call",
        "title": "Match Function Call in C",
        "description": "One of the common questions of ast-grep is to match function calls in C.\n\nA plain pattern like `test($A)` will not work. This is because [tree-sitter-c](https://github.com/tree-sitter/tree-sitter-c)\nparse the code snippet into `macro_type_specifier`, see the [pattern output](https://ast-grep.github.io/playground.html#eyJtb2RlIjoiUGF0Y2giLCJsYW5nIjoiYyIsInF1ZXJ5IjoidGVzdCgkJCQpIiwicmV3cml0ZSI6IiIsImNvbmZpZyI6InJ1bGU6XG4gIHBhdHRlcm46IFxuICAgIGNvbnRleHQ6ICRNKCQkJCk7XG4gICAgc2VsZWN0b3I6IGNhbGxfZXhwcmVzc2lvbiIsInNvdXJjZSI6IiNkZWZpbmUgdGVzdCh4KSAoMip4KVxuaW50IGEgPSB0ZXN0KDIpO1xuaW50IG1haW4oKXtcbiAgICBpbnQgYiA9IHRlc3QoMik7XG59In0=).\n\nTo avoid this ambiguity, ast-grep lets us write a [contextual pattern](/guide/rule-config/atomic-rule.html#pattern), which is a pattern inside a larger code snippet.\nWe can use `context` to write a pattern like this: `test($A);`. Then, we can use the selector `call_expression` to match only function calls.",
        "language": "c",
        "file": "match-function-call.md",
        "has_fix": false,
        "pattern": {
          "context": "$M($$$);",
          "selector": "call_expression"
        },
        "quality": "neutral",
        "weight": 1
      }
    ],
    "ruby_catalog": [
      {
        "id": "prefer-symbol-over-proc",
        "title": "Prefer Symbol over Proc",
        "description": "Ruby has a more concise symbol shorthand `&:` to invoke methods.\nThis rule simplifies `proc` to `symbol`.\nThis example is inspired by this [dev.to article](https://dev.to/baweaver/future-of-ruby-ast-tooling-9i1).\n\n\n<!-- Use YAML in the example. Delete this section if use pattern. -->",
        "language": "ruby",
        "file": "prefer-symbol-over-proc.md",
        "has_fix": true,
        "pattern": "$LIST.$ITER { |$V| $V.$METHOD }",
        "fix": "$LIST.$ITER(&:$METHOD)",
        "quality": "good",
        "weight": 3
      },
      {
        "id": "migration-action-filter",
        "title": "Migrate action_filter in Ruby on Rails",
        "description": "This rule is used to migrate `{before,after,around}_filter` to `{before,after,around}_action` in Ruby on Rails controllers.\n\nThese are methods that run before, after or around an action is executed, and they can be used to check permissions, set variables, redirect requests, log events, etc. However, these methods are [deprecated](https://stackoverflow.com/questions/16519828/rails-4-before-filter-vs-before-action) in Rails 5.0 and will be removed in Rails 5.1. `{before,after,around}_action` are the new syntax for the same functionality.\n\nThis rule will replace all occurrences of `{before,after,around}_filter` with `{before,after,around}_action` in the controller code.",
        "language": "ruby",
        "file": "migrate-action-filter.md",
        "has_fix": true,
        "patterns": [
          {
            "pattern": "before_filter $$$ACTION"
          },
          {
            "pattern": "around_filter $$$ACTION"
          },
          {
            "pattern": "after_filter $$$ACTION"
          }
        ],
        "match_type": "any",
        "fix": "$NEW_ACTION $$$ACTION",
        "quality": "good",
        "weight": 3
      }
    ],
    "python_security": [
      {
        "id": "subprocess-shell-true",
        "pattern": "subprocess.$METHOD($$$, shell=True, $$$)",
        "description": "Shell injection vulnerability - using shell=True",
        "quality": "bad",
        "weight": -10,
        "language": "python",
        "severity": "critical",
        "fix": "Use list args without shell=True"
      },
      {
        "id": "subprocess-run-check",
        "pattern": "subprocess.run($$$)",
        "description": "Potential shell invocation - check for shell=True",
        "quality": "warning",
        "weight": -3,
        "language": "python",
        "severity": "high"
      },
      {
        "id": "subprocess-popen-check",
        "pattern": "subprocess.Popen($$$)",
        "description": "Potential shell invocation - check for shell=True",
        "quality": "warning",
        "weight": -3,
        "language": "python",
        "severity": "high"
      },
      {
        "id": "os-system",
        "pattern": "os.system($$$)",
        "description": "Direct shell command execution - security risk",
        "quality": "bad",
        "weight": -10,
        "language": "python",
        "severity": "critical"
      },
      {
        "id": "eval-usage",
        "pattern": "eval($$$)",
        "description": "Dangerous eval usage - code injection risk",
        "quality": "bad",
        "weight": -10,
        "language": "python",
        "severity": "critical"
      },
      {
        "id": "exec-usage",
        "pattern": "exec($$$)",
        "description": "Dangerous exec usage - code injection risk",
        "quality": "bad",
        "weight": -10,
        "language": "python",
        "severity": "critical"
      }
    ],
    "python_exceptions": [
      {
        "id": "bare-except",
        "pattern": "except:\n    $$$",
        "description": "Bare except clause without exception type",
        "quality": "bad",
        "weight": -5,
        "language": "python",
        "severity": "high",
        "fix": "Use specific exception types"
      },
      {
        "id": "broad-exception",
        "pattern": "except Exception:\n    $$$",
        "description": "Too broad exception catching",
        "quality": "bad",
        "weight": -3,
        "language": "python",
        "severity": "medium",
        "fix": "Catch specific exception types"
      },
      {
        "id": "broad-exception-as-e",
        "pattern": "except Exception as $VAR:\n    $$$",
        "description": "Broad exception with variable",
        "quality": "warning",
        "weight": -2,
        "language": "python",
        "severity": "medium"
      },
      {
        "id": "multiple-specific-exceptions",
        "pattern": "except ($EX1, $EX2) as $VAR:\n    $$$",
        "description": "Multiple specific exceptions (good)",
        "quality": "good",
        "weight": 3,
        "language": "python"
      },
      {
        "id": "suppress-exception",
        "pattern": "except $$$:\n    pass",
        "description": "Silently suppressing exceptions",
        "quality": "bad",
        "weight": -4,
        "language": "python",
        "severity": "high",
        "fix": "Log exceptions or handle properly"
      }
    ],
    "python_imports": [
      {
        "id": "missing-import-usage",
        "pattern": "$MODULE.$METHOD($$$)",
        "description": "Using module without import",
        "quality": "bad",
        "weight": -5,
        "language": "python",
        "severity": "critical",
        "context": "Check if $MODULE is imported"
      },
      {
        "id": "unused-import",
        "pattern": "import $MODULE",
        "description": "Import that may be unused",
        "quality": "warning",
        "weight": -1,
        "language": "python",
        "context": "Check if $MODULE is used in file"
      }
    ],
    "python_type_safety": [
      {
        "id": "mutable-class-attribute",
        "pattern": "class $CLASS:\n    $ATTR = []",
        "description": "Mutable class attribute without ClassVar",
        "quality": "bad",
        "weight": -4,
        "language": "python",
        "severity": "high",
        "fix": "Use ClassVar[List[...]]"
      },
      {
        "id": "mutable-class-dict",
        "pattern": "class $CLASS:\n    $ATTR = {}",
        "description": "Mutable dict class attribute without ClassVar",
        "quality": "bad",
        "weight": -4,
        "language": "python",
        "severity": "high",
        "fix": "Use ClassVar[Dict[...]]"
      }
    ],
    "python_strings": [
      {
        "id": "fstring-no-placeholder",
        "pattern": "f\"$STRING\"",
        "description": "f-string without placeholders",
        "quality": "warning",
        "weight": -1,
        "language": "python",
        "severity": "low",
        "fix": "Remove f prefix",
        "context": "Check if $STRING contains {}"
      },
      {
        "id": "redundant-dict-check",
        "pattern": "if '$KEY' in $DICT and $DICT['$KEY']:",
        "description": "Redundant dictionary key check",
        "quality": "warning",
        "weight": -2,
        "language": "python",
        "fix": "Use dict.get('key')"
      }
    ],
    "python_hashing": [
      {
        "id": "md5-usage",
        "pattern": "hashlib.md5($$$)",
        "description": "MD5 is cryptographically broken",
        "quality": "bad",
        "weight": -8,
        "language": "python",
        "severity": "high",
        "fix": "Use SHA-256 or SHA-3"
      },
      {
        "id": "sha1-usage",
        "pattern": "hashlib.sha1($$$)",
        "description": "SHA-1 is deprecated for security",
        "quality": "bad",
        "weight": -6,
        "language": "python",
        "severity": "medium",
        "fix": "Use SHA-256 or SHA-3"
      }
    ],
    "python_paths": [
      {
        "id": "hardcoded-tmp",
        "pattern": "\"/tmp/$$$\"",
        "description": "Hardcoded /tmp path - security risk",
        "quality": "bad",
        "weight": -5,
        "language": "python",
        "severity": "medium",
        "fix": "Use tempfile module"
      },
      {
        "id": "hardcoded-user-path",
        "pattern": "\"/Users/$USER/$$$\"",
        "description": "Hardcoded user-specific path",
        "quality": "bad",
        "weight": -3,
        "language": "python",
        "severity": "low",
        "fix": "Use Path.home() or environment variables"
      },
      {
        "id": "tilde-path",
        "pattern": "\"~/$$$\"",
        "description": "Using tilde in path",
        "quality": "warning",
        "weight": -2,
        "language": "python",
        "fix": "Use os.path.expanduser() or Path.home()"
      }
    ],
    "python_unused": [
      {
        "id": "unused-variable",
        "pattern": "$VAR = $VALUE\n$$$",
        "description": "Variable assigned but never used",
        "quality": "warning",
        "weight": -2,
        "language": "python",
        "severity": "low",
        "context": "Check if $VAR is used after assignment"
      },
      {
        "id": "unused-loop-variable",
        "pattern": "for $VAR in $ITER:\n    $$$",
        "description": "Loop variable not used in loop body",
        "quality": "warning",
        "weight": -2,
        "language": "python",
        "fix": "Use _ for unused variables",
        "context": "Check if $VAR is used in loop body"
      }
    ],
    "python_psutil": [
      {
        "id": "psutil-without-import",
        "pattern": "psutil.$METHOD($$$)",
        "description": "Using psutil without import",
        "quality": "bad",
        "weight": -5,
        "language": "python",
        "severity": "critical"
      },
      {
        "id": "psutil-exception-handling",
        "pattern": "except psutil.$ERROR:",
        "description": "Handling psutil exception without import",
        "quality": "bad",
        "weight": -5,
        "language": "python",
        "severity": "critical"
      }
    ],
    "python_best_practices": [
      {
        "id": "specific-exception-multi",
        "pattern": "except (IOError, OSError) as e:",
        "description": "Specific exception handling for I/O",
        "quality": "good",
        "weight": 5,
        "language": "python"
      },
      {
        "id": "json-decode-error",
        "pattern": "except json.JSONDecodeError:",
        "description": "Specific JSON error handling",
        "quality": "good",
        "weight": 4,
        "language": "python"
      },
      {
        "id": "value-error-handling",
        "pattern": "except (ValueError, TypeError):",
        "description": "Value/Type error handling",
        "quality": "good",
        "weight": 4,
        "language": "python"
      },
      {
        "id": "subprocess-list-args",
        "pattern": "subprocess.run([$$$], $$$)",
        "description": "Subprocess with list args (safe)",
        "quality": "good",
        "weight": 5,
        "language": "python"
      },
      {
        "id": "pathlib-usage",
        "pattern": "Path($$$)",
        "description": "Using pathlib for paths",
        "quality": "good",
        "weight": 3,
        "language": "python"
      },
      {
        "id": "context-manager",
        "pattern": "with $RESOURCE as $VAR:",
        "description": "Using context manager",
        "quality": "good",
        "weight": 4,
        "language": "python"
      },
      {
        "id": "logger-usage",
        "pattern": "logger.$LEVEL($$$)",
        "description": "Using logger instead of print",
        "quality": "good",
        "weight": 3,
        "language": "python"
      }
    ]
  },
  "stats": {
    "total_patterns": 59,
    "categories": [
      "python_async",
      "python_error_handling",
      "python_logging",
      "python_typing",
      "python_antipatterns",
      "python_qdrant",
      "python_mcp",
      "go_catalog",
      "python_catalog",
      "tsx_catalog",
      "typescript_catalog",
      "rust_catalog",
      "java_catalog",
      "html_catalog",
      "kotlin_catalog",
      "cpp_catalog",
      "yaml_catalog",
      "c_catalog",
      "ruby_catalog"
    ],
    "languages": [
      "java",
      "c",
      "ruby",
      "rust",
      "kotlin",
      "tsx",
      "typescript",
      "html",
      "yaml",
      "python",
      "go",
      "cpp"
    ],
    "last_update": "2025-09-27T15:46:29.864719"
  },
  "statistics": {
    "total_patterns": 92,
    "categories": 29,
    "last_coderabbit_update": "2025-09-27T17:52:59.761597",
    "coderabbit_patterns_added": 33
  }
}