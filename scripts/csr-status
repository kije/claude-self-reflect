#!/usr/bin/env python3
"""
Claude Self-Reflect Status for CC Statusline
Standalone script that doesn't require venv activation.
"""

import json
import time
import os
from pathlib import Path
from datetime import datetime, timedelta
import sys

# Configuration
CYCLE_FILE = Path.home() / ".claude-self-reflect" / "statusline_cycle.json"
CYCLE_INTERVAL = 5  # seconds between cycles


def get_import_status():
    """Get current import/indexing status."""
    state_file = Path.home() / ".claude-self-reflect" / "config" / "imported-files.json"

    if not state_file.exists():
        return "ðŸ“š CSR: Not configured"

    try:
        with open(state_file, 'r') as f:
            state = json.load(f)

        imported = len(state.get("imported_files", {}))

        # Count total JSONL files
        claude_dir = Path.home() / ".claude" / "projects"
        total = 0
        if claude_dir.exists():
            for project_dir in claude_dir.iterdir():
                if project_dir.is_dir():
                    total += len(list(project_dir.glob("*.jsonl")))

        if total == 0:
            return "ðŸ“š CSR: No files"

        percent = min(100, (imported / total * 100))

        # Color coding
        if percent >= 95:
            emoji = "âœ…"
        elif percent >= 50:
            emoji = "ðŸ”„"
        else:
            emoji = "â³"

        return f"{emoji} CSR: {percent:.0f}% indexed"

    except Exception:
        return "ðŸ“š CSR: Error"


def categorize_issues(file_reports):
    """
    Categorize issues from AST analysis into critical/medium/low.
    """
    critical = 0
    medium = 0
    low = 0

    for file_path, report in file_reports.items():
        # Only use top_issues for accurate counting (avoid double-counting from recommendations)
        for issue in report.get('top_issues', []):
            severity = issue.get('severity', 'medium')
            count = issue.get('count', 0)
            issue_id = issue.get('id', '').lower()

            if severity == 'high' or severity == 'critical':
                critical += count
            elif severity == 'medium':
                # Console.log and print statements are low severity
                if 'print' in issue_id or 'console' in issue_id:
                    low += count
                else:
                    medium += count
            else:
                low += count

    return critical, medium, low


def get_quality_icon(critical=0, medium=0, low=0):
    """
    Determine quality icon based on issue severity counts.
    """
    # Icon selection based on highest severity present
    if critical > 0:
        if critical >= 10:
            return "ðŸ”´"  # Red circle - Critical issues need immediate attention
        else:
            return "ðŸŸ "  # Orange circle - Some critical issues
    elif medium > 0:
        if medium >= 50:
            return "ðŸŸ¡"  # Yellow circle - Many medium issues
        else:
            return "ðŸŸ¢"  # Green circle - Few medium issues
    elif low > 0:
        if low >= 100:
            return "âšª"  # White circle - Many minor issues (prints)
        else:
            return "âœ…"  # Check mark - Only minor issues
    else:
        return "âœ¨"  # Sparkles - Perfect, no issues


def format_statusline_quality(critical=0, medium=0, low=0):
    """
    Format statusline with colored dot and labeled numbers.
    """
    import os
    icon = get_quality_icon(critical, medium, low)

    # Check if we should use colors (when in a TTY)
    use_colors = os.isatty(sys.stdout.fileno()) if hasattr(sys.stdout, 'fileno') else False

    # Build count display with colors if supported
    counts = []
    if critical > 0:
        if use_colors:
            # Use bright red for critical
            counts.append(f"\033[1;31mC:{critical}\033[0m")
        else:
            counts.append(f"C:{critical}")
    if medium > 0:
        if use_colors:
            # Use bright yellow for medium
            counts.append(f"\033[1;33mM:{medium}\033[0m")
        else:
            counts.append(f"M:{medium}")
    if low > 0:
        if use_colors:
            # Use bright white/gray for low
            counts.append(f"\033[1;37mL:{low}\033[0m")
        else:
            counts.append(f"L:{low}")

    if counts:
        return f"{icon} {' '.join(counts)}"
    else:
        return f"{icon}"  # Perfect - no counts needed


def get_session_health():
    """Get cached session health with icon-based quality display."""
    # Get project-specific cache based on current directory
    project_dir = os.getcwd()
    project_name = os.path.basename(project_dir) if project_dir else "default"

    # Check project-specific realtime cache first
    quality_dir = Path.home() / ".claude-self-reflect" / "quality_by_project"
    realtime_cache = quality_dir / f"{project_name}.json"

    # Fallback to global cache if project-specific doesn't exist
    if not realtime_cache.exists():
        realtime_cache = Path.home() / ".claude-self-reflect" / "realtime_quality.json"

    if realtime_cache.exists():
        try:
            # Check realtime cache age
            mtime = datetime.fromtimestamp(realtime_cache.stat().st_mtime)
            age = datetime.now() - mtime

            if age < timedelta(minutes=5):  # Fresh realtime data
                with open(realtime_cache, 'r') as f:
                    realtime_data = json.load(f)

                if "session_aggregate" in realtime_data:
                    agg = realtime_data["session_aggregate"]
                    issues = agg.get("total_issues", {})
                    critical = issues.get("critical", 0)
                    medium = issues.get("medium", 0)
                    low = issues.get("low", 0)

                    # Include score in display if significantly below threshold
                    score = agg.get("average_score", 100)
                    if critical > 0 or medium > 0 or low > 0:
                        # Show issue counts when there are any issues
                        return format_statusline_quality(critical, medium, low)
                    elif score < 70:
                        # Use red icon for scores below threshold (no issues but poor score)
                        icon = "ðŸ”´"
                        return f"{icon} {score:.0f}%"
                    else:
                        # Good quality, no issues
                        return format_statusline_quality(critical, medium, low)
        except Exception:
            pass  # Fall back to old cache system

    # Fall back to old cache system
    # Check for session edit tracker to show appropriate label
    tracker_file = Path.home() / ".claude-self-reflect" / "current_session_edits.json"

    # Get quality cache file for current project
    project_name = Path.cwd().name
    cache_file = Path.home() / ".claude-self-reflect" / "quality_cache" / f"{project_name}.json"

    # Default label prefix
    label_prefix = ""

    # Check if we have a session tracker with edited files
    if tracker_file.exists():
        try:
            with open(tracker_file, 'r') as f:
                tracker_data = json.load(f)
                edited_files = tracker_data.get('edited_files', [])
                if edited_files:
                    # Show session label with file count
                    file_count = len(edited_files)
                    label_prefix = f"Session ({file_count} file{'s' if file_count > 1 else ''}): "
        except:
            pass

    if not cache_file.exists():
        # Fall back to import status if no health data
        return get_import_status()

    try:
        # Check cache age
        mtime = datetime.fromtimestamp(cache_file.stat().st_mtime)
        age = datetime.now() - mtime

        if age > timedelta(minutes=5):
            # Fall back to import status if stale
            return get_import_status()

        with open(cache_file, 'r') as f:
            data = json.load(f)

        if data.get('status') != 'success':
            # Fall back to import status if no session
            return get_import_status()

        # Extract issue counts by severity
        file_reports = data.get('file_reports', {})
        critical, medium, low = categorize_issues(file_reports)

        # Use the icon-based display with optional label
        quality_display = format_statusline_quality(critical, medium, low)

        # Add session label if we have one
        if data.get('scope_label') == 'Session':
            # For session scope, always show the label with counts
            if label_prefix:
                if critical == 0 and medium == 0 and low == 0:
                    return f"{label_prefix}0 0 0 {quality_display}"
                else:
                    return f"{label_prefix}{critical} {medium} {low} {quality_display}"
            else:
                # Fallback if no tracker file
                return f"Session: {critical} {medium} {low} {quality_display}"

        return quality_display

    except Exception:
        return get_import_status()


def get_current_cycle():
    """Determine which metric to show based on cycle."""
    # Read or create cycle state
    cycle_state = {"last_update": 0, "current": "import"}

    if CYCLE_FILE.exists():
        try:
            with open(CYCLE_FILE, 'r') as f:
                cycle_state = json.load(f)
        except:
            pass

    # Check if it's time to cycle
    now = time.time()
    if now - cycle_state["last_update"] >= CYCLE_INTERVAL:
        # Toggle between import and health
        cycle_state["current"] = "health" if cycle_state["current"] == "import" else "import"
        cycle_state["last_update"] = now

        # Save state
        CYCLE_FILE.parent.mkdir(exist_ok=True)
        with open(CYCLE_FILE, 'w') as f:
            json.dump(cycle_state, f)

    return cycle_state["current"]


def get_compact_status():
    """Get both import and quality in compact format: [100%][ðŸŸ¢:A+]"""
    import subprocess
    import os
    import re
    import shutil

    # Get project-specific status using claude-self-reflect status command
    import_pct = "?"
    time_behind = ""

    try:
        # Get current working directory to determine project
        cwd = os.getcwd()
        project_name = os.path.basename(cwd)

        # Get status from claude-self-reflect with secure path
        import shutil
        csr_binary = shutil.which("claude-self-reflect")
        if not csr_binary or not os.path.isfile(csr_binary):
            # Fallback if binary not found
            import_pct = "?"
            return f"[{import_pct}]"

        result = subprocess.run(
            [csr_binary, "status"],
            capture_output=True,
            text=True,
            timeout=2
        )

        if result.returncode == 0:
            status_data = json.loads(result.stdout)

            # Try to find project-specific percentage
            project_pct = None
            encoded_path = None

            # Try exact project name FIRST
            if project_name in status_data.get("projects", {}):
                project_pct = status_data["projects"][project_name].get("percentage")
                encoded_path = project_name  # Use project name for file lookup

            # Only try encoded path if exact match not found
            elif project_pct is None:
                # Convert path to encoded format
                encoded_path = cwd.replace("/", "-")
                if encoded_path.startswith("-"):
                    encoded_path = encoded_path[1:]  # Remove leading dash

                if encoded_path in status_data.get("projects", {}):
                    project_pct = status_data["projects"][encoded_path].get("percentage")

            # Use project percentage if found, otherwise use overall
            if project_pct is not None:
                pct = int(project_pct)
            else:
                pct = int(status_data.get("overall", {}).get("percentage", 0))

            import_pct = f"{pct}%"

            # Only show time behind if NOT at 100%
            # This indicates how old the unindexed files are
            if pct < 100:
                # Check for newest unindexed file
                state_file = Path.home() / ".claude-self-reflect" / "config" / "imported-files.json"
                if state_file.exists():
                    with open(state_file, 'r') as f:
                        state = json.load(f)

                    # Find project directory
                    claude_dir = Path.home() / ".claude" / "projects"
                    if encoded_path:
                        project_dir = claude_dir / encoded_path
                        if not project_dir.exists() and not encoded_path.startswith("-"):
                            project_dir = claude_dir / f"-{encoded_path}"

                        if project_dir.exists():
                            # Find the newest UNINDEXED file
                            newest_unindexed_time = None
                            for jsonl_file in project_dir.glob("*.jsonl"):
                                file_key = str(jsonl_file)
                                # Only check unindexed files
                                if file_key not in state.get("imported_files", {}):
                                    file_time = datetime.fromtimestamp(jsonl_file.stat().st_mtime)
                                    if newest_unindexed_time is None or file_time > newest_unindexed_time:
                                        newest_unindexed_time = file_time

                            # Calculate how behind we are
                            if newest_unindexed_time:
                                age = datetime.now() - newest_unindexed_time
                                if age < timedelta(minutes=5):
                                    time_behind = " <5m"
                                elif age < timedelta(hours=1):
                                    time_behind = f" {int(age.total_seconds() / 60)}m"
                                elif age < timedelta(days=1):
                                    time_behind = f" {int(age.total_seconds() / 3600)}h"
                                else:
                                    time_behind = f" {int(age.days)}d"
    except:
        # Fallback to simple file counting
        state_file = Path.home() / ".claude-self-reflect" / "config" / "imported-files.json"
        if state_file.exists():
            try:
                with open(state_file, 'r') as f:
                    state = json.load(f)
                imported = len(state.get("imported_files", {}))

                claude_dir = Path.home() / ".claude" / "projects"
                total = 0
                if claude_dir.exists():
                    for project_dir in claude_dir.iterdir():
                        if project_dir.is_dir():
                            total += len(list(project_dir.glob("*.jsonl")))

                if total > 0:
                    pct = min(100, int(imported / total * 100))
                    import_pct = f"{pct}%"
            except:
                pass

    # Get project-specific cache based on current directory
    project_name = os.path.basename(os.getcwd()) if os.getcwd() else "default"

    # Check project-specific realtime cache first
    quality_dir = Path.home() / ".claude-self-reflect" / "quality_by_project"
    realtime_cache = quality_dir / f"{project_name}.json"

    # Fallback to global cache if project-specific doesn't exist
    if not realtime_cache.exists():
        realtime_cache = Path.home() / ".claude-self-reflect" / "realtime_quality.json"

    grade_str = ""
    quality_valid = False

    if realtime_cache.exists():
        try:
            mtime = datetime.fromtimestamp(realtime_cache.stat().st_mtime)
            age = datetime.now() - mtime
            if age < timedelta(minutes=5):  # Fresh realtime data
                with open(realtime_cache, 'r') as f:
                    realtime_data = json.load(f)

                if "session_aggregate" in realtime_data:
                    agg = realtime_data["session_aggregate"]
                    issues = agg.get("total_issues", {})
                    critical = issues.get("critical", 0)
                    medium = issues.get("medium", 0)
                    low = issues.get("low", 0)
                    score = agg.get("average_score", 100)

                    # Get icon based on score and issues
                    if score < 70:
                        icon = "ðŸ”´"  # Red for below threshold
                    else:
                        icon = get_quality_icon(critical, medium, low)

                    # Build compact display
                    if critical > 0 or medium > 0 or low > 0:
                        # Show issue counts when there are any issues
                        colored_parts = []
                        if critical > 0:
                            colored_parts.append(f"C:{critical}")
                        if medium > 0:
                            colored_parts.append(f"M:{medium}")
                        if low > 0:
                            colored_parts.append(f"L:{low}")
                        grade_str = f"[{icon}:{'Â·'.join(colored_parts)}]"
                    elif score < 70:
                        # Show score when below threshold but no specific issues
                        grade_str = f"[{icon}:{score:.0f}%]"
                    else:
                        grade_str = f"[{icon}]"
                    quality_valid = True
        except:
            pass

    # Setup cache file path for fallback
    project_name = os.path.basename(os.getcwd())
    # Secure sanitization with whitelist approach
    import re
    safe_project_name = re.sub(r'[^a-zA-Z0-9_-]', '_', project_name)[:100]
    cache_dir = Path.home() / ".claude-self-reflect" / "quality_cache"
    cache_file = cache_dir / f"{safe_project_name}.json"

    # Fall back to old cache if no realtime data
    if not quality_valid:

        # If the exact cache file doesn't exist, try to find one that ends with this project name
        # This handles cases like "metafora-Atlas-gold.json" for project "Atlas-gold"
        if not cache_file.exists():
            # Look for files ending with the project name
            possible_files = list(cache_dir.glob(f"*-{safe_project_name}.json"))
            if possible_files:
                cache_file = possible_files[0]  # Use the first match

        # Validate cache file path stays within cache directory
        if cache_file.exists() and not str(cache_file.resolve()).startswith(str(cache_dir.resolve())):
            # Security issue - return placeholder
            grade_str = "[...]"
        else:
            cache_file.parent.mkdir(exist_ok=True, parents=True)

    # Try to get quality data (regenerate if too old or missing)
    quality_valid = False

    if cache_file.exists():
        try:
            mtime = datetime.fromtimestamp(cache_file.stat().st_mtime)
            age = datetime.now() - mtime

            # Use quality data up to 30 minutes old for fresher results
            if age < timedelta(minutes=30):
                with open(cache_file, 'r') as f:
                    data = json.load(f)

                if data.get('status') == 'non-code':
                    # Non-code project - show documentation indicator
                    grade_str = "[ðŸ“š:Docs]"
                    quality_valid = True
                elif data.get('status') == 'success':
                    # Extract issue counts by severity for icon display
                    file_reports = data.get('file_reports', {})
                    critical, medium, low = categorize_issues(file_reports)

                    # Get icon based on severity
                    icon = get_quality_icon(critical, medium, low)

                    # Build compact display with ANSI colors for each severity level
                    colored_parts = []
                    if critical > 0:
                        colored_parts.append(f"\033[31m{critical}\033[0m")  # Standard red for critical
                    if medium > 0:
                        colored_parts.append(f"\033[33m{medium}\033[0m")  # Standard yellow for medium
                    if low > 0:
                        colored_parts.append(f"\033[37m{low}\033[0m")  # White/light gray for low

                    # Join with middle dot separator
                    if colored_parts:
                        grade_str = f"[{icon}:{'Â·'.join(colored_parts)}]"
                    else:
                        grade_str = f"[{icon}]"

                    quality_valid = True
        except:
            pass

    # If no valid quality data, show last known value or placeholder
    if not quality_valid and not grade_str:
        # Try to use last known value from cache even if expired
        try:
            if cache_file.exists():
                with open(cache_file, 'r') as f:
                    old_data = json.load(f)
                if old_data.get('status') == 'non-code':
                    # Non-code project - show documentation indicator
                    grade_str = "[ðŸ“š:Docs]"
                elif old_data.get('status') == 'success':
                    # Extract issue counts by severity for icon display
                    file_reports = old_data.get('file_reports', {})
                    critical, medium, low = categorize_issues(file_reports)

                    # Get icon based on severity
                    icon = get_quality_icon(critical, medium, low)

                    # Build compact display with ANSI colors for each severity level
                    colored_parts = []
                    if critical > 0:
                        colored_parts.append(f"\033[31m{critical}\033[0m")  # Standard red for critical
                    if medium > 0:
                        colored_parts.append(f"\033[33m{medium}\033[0m")  # Standard yellow for medium
                    if low > 0:
                        colored_parts.append(f"\033[37m{low}\033[0m")  # White/light gray for low

                    # Join with middle dot separator
                    if colored_parts:
                        grade_str = f"[{icon}:{'Â·'.join(colored_parts)}]"
                    else:
                        grade_str = f"[{icon}]"
                else:
                    grade_str = "[...]"
            else:
                grade_str = "[...]"
        except:
            grade_str = "[...]"

    # Add mini progress bar if not 100%
    bar_str = ""
    if import_pct != "?" and import_pct != "100%":
        pct_num = int(import_pct.rstrip('%'))
        filled = int(pct_num * 4 / 100)  # 4-char mini bar
        empty = 4 - filled
        bar_str = "â–ˆ" * filled + "â–‘" * empty + " "

    # Return compact format with bar, percentage, time behind, and grade
    return f"[{bar_str}{import_pct}{time_behind}]{grade_str}"

def main():
    """Main entry point for CC statusline."""
    # Check for forced mode
    if len(sys.argv) > 1:
        if sys.argv[1] == "--import":
            print(get_import_status())
        elif sys.argv[1] == "--health":
            print(get_session_health())
        elif sys.argv[1] == "--quality-only":
            # Only show quality, not import (to avoid duplication with MCP status)
            health = get_session_health()
            # Only show if it's actual quality data, not fallback to import
            if "Code:" in health:
                print(health)
        elif sys.argv[1] == "--compact":
            print(get_compact_status())
        else:
            # Default to compact mode
            print(get_compact_status())
        return

    # Default to compact format (no cycling)
    print(get_compact_status())


if __name__ == "__main__":
    main()