#!/bin/bash
# Post-generation hook for Claude Self-Reflect
# Optimized version - runs quality checks asynchronously to avoid lag
set -euo pipefail

# Get the directory of this script
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
TRACKER_FILE="$HOME/.claude-self-reflect/current_session_edits.json"
CACHE_FILE="$HOME/.claude-self-reflect/realtime_quality_cache.json"

# Check if any files were edited in the last 30 seconds (reduced from 60)
EDITED_FILES=$(python3 - <<'PY'
import os, sys, time
exts = {'.py','.ts','.js','.tsx','.jsx'}
cutoff = time.time() - 30  # Reduced time window
skip_dirs = {'.git','node_modules','venv','.venv','dist','build','__pycache__'}
for root, dirs, files in os.walk('.'):
    dirs[:] = [d for d in dirs if d not in skip_dirs]
    if any(s in root for s in skip_dirs):
        continue
    for fn in files:
        if os.path.splitext(fn)[1] in exts:
            p = os.path.join(root, fn)
            try:
                if os.path.getmtime(p) >= cutoff:
                    print(p)
            except OSError:
                pass
PY
)

if [ -z "$EDITED_FILES" ]; then
    exit 0  # No recent edits, nothing to analyze
fi

# Update tracker file asynchronously
(
    # Create tracker file if it doesn't exist
    if [ ! -f "$TRACKER_FILE" ]; then
        echo '{"session_start":"'$(date -u +"%Y-%m-%dT%H:%M:%S")'","edited_files":[],"last_updated":"'$(date -u +"%Y-%m-%dT%H:%M:%S")'","project":"'$(basename "$PWD")'"}' > "$TRACKER_FILE"
    fi

    # Add edited files to tracker
    python3 -c "
import json
from pathlib import Path

tracker_file = '$TRACKER_FILE'
edited_files = '''$EDITED_FILES'''.strip().split('\n') if '''$EDITED_FILES''' else []

try:
    with open(tracker_file, 'r') as f:
        tracker = json.load(f)
except:
    tracker = {
        'session_start': '$(date -u +"%Y-%m-%dT%H:%M:%S")',
        'edited_files': [],
        'project': '$(basename "$PWD")'
    }

for file in edited_files:
    if file:
        abs_path = str(Path(file).resolve())
        if abs_path not in tracker['edited_files']:
            tracker['edited_files'].append(abs_path)

tracker['last_updated'] = '$(date -u +"%Y-%m-%dT%H:%M:%S")'

with open(tracker_file, 'w') as f:
    json.dump(tracker, f, indent=2)
" 2>/dev/null
) &

# Run quick quality check asynchronously with short timeout
# This updates the cache but doesn't block
(
    if [ -f "$PROJECT_ROOT/venv/bin/python" ]; then
        PYTHON_CMD="$PROJECT_ROOT/venv/bin/python"
    else
        PYTHON_CMD="python3"
    fi

    # Update cache in background (500ms timeout, non-blocking)
    timeout 0.5s $PYTHON_CMD "$PROJECT_ROOT/scripts/session_quality_tracker.py" \
        --use-tracker --update-cache-only 2>/dev/null || true
) &

# For critical issues only, run a quick check (100ms timeout)
if [ -f "$CACHE_FILE" ]; then
    # Check cache for critical issues
    CRITICAL_ISSUES=$(python3 -c "
import json
import time
try:
    with open('$CACHE_FILE', 'r') as f:
        cache = json.load(f)
    # Only report if cache is fresh (< 5 seconds old)
    if time.time() - cache.get('timestamp', 0) < 5:
        score = cache.get('overall_score', 100)
        if score < 70:  # Only report serious issues
            print(f'Quality score: {score}%')
except:
    pass
" 2>/dev/null)

    if [ -n "$CRITICAL_ISSUES" ]; then
        echo "⚠️ $CRITICAL_ISSUES - Consider reviewing recent changes" >&2
    fi
fi

# Always exit successfully to avoid blocking
exit 0